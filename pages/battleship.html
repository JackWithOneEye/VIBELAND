<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>VIBELAND - Battleship</title>
  <link rel="stylesheet" type="text/css" href="../assets/styles.css">
  <style>
    /* Battleship page styles aligned to VIBELAND retro theme */
    .boards {
      display: flex;
      justify-content: center;
      gap: 30px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    .board-wrapper {
      background-color: #ffffff;
      border: 2px inset #c0c0c0;
      padding: 12px;
      text-align: center;
    }

    .board-label {
      color: #000080;
      font-weight: bold;
      margin-bottom: 8px;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(10, 30px);
      grid-template-rows: repeat(10, 30px);
      gap: 2px;
      background: #ffffff;
      border: 2px inset #c0c0c0;
      margin-bottom: 8px;
    }

    .cell {
      width: 30px;
      height: 30px;
      background: #ffffff; /* brightest */
      border: 1px solid #808080; /* darker border for contrast */
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 1.1em;
      user-select: none;
      color: #000000;
    }

    .cell.own { /* player's grid base */
      background: #e6e6e6; /* clearly darker than base */
      cursor: default;
    }

    .cell.ship { /* reveal ships on player board */
      background: #bfbfbf; /* significantly darker */
      border-color: #808080;
    }

    .cell.hit {
      background: #ff0000; /* strong red */
      color: #ffffff;
      cursor: default;
      border-color: #800000; /* darker red border */
    }

    .cell.miss {
      background: #ffffcc; /* pale yellow for clear contrast */
      color: #000000;
      cursor: default;
      border-color: #c0c0c0;
    }

    .cell.sunk {
      background: #000080;
      color: #ffffff;
      font-weight: bold;
    }

    #controls {
      margin-top: 16px;
      text-align: center;
    }

    #message {
      margin-top: 14px;
      min-height: 32px;
      font-size: 1.1em;
      color: #000080;
      background-color: #ffffff;
      border: 2px inset #c0c0c0;
      padding: 10px;
    }

    select {
      padding: 6px 8px;
      border: 2px inset #c0c0c0;
      background-color: #ffffff;
      color: #000000;
      font-family: "Times New Roman", serif;
    }

    @media (max-width: 768px) {
      .boards { gap: 16px; }
    }
  </style>
</head>

<body>
  <div class="container wide">
    <h1>VIBELAND BATTLESHIP</h1>

    <div class="instructions" id="ai-greeting"></div>

    <div class="boards">
      <div class="board-wrapper">
        <div class="board-label">Your Board</div>
        <div id="player-board" class="board"></div>
      </div>
      <div class="board-wrapper">
        <div class="board-label">Enemy Board</div>
        <div id="ai-board" class="board"></div>
      </div>
    </div>

    <div id="controls" class="controls">
      <label for="difficulty">AI Difficulty:</label>
      <select id="difficulty">
        <option value="easy">Easy</option>
        <option value="normal" selected>Normal</option>
        <option value="hard">Hard</option>
      </select>
      <button id="restart-btn">Restart Game</button>
    </div>

    <div id="message"></div>

    <div class="footer">
      <p><a href="../index.html" class="home-link">← Back to VIBELAND</a></p>
      <p>© 1999 VIBELAND - All Rights Reserved</p>
    </div>
  </div>

  <script>
    // Game constants
    const SIZE = 10;
    const SHIPS = [
      {name: "Carrier", size: 5},
      {name: "Battleship", size: 4},
      {name: "Cruiser", size: 3},
      {name: "Submarine", size: 3},
      {name: "Destroyer", size: 2}
    ];
    const DIRS = ["H", "V"];

    // Game state
    let playerBoard, aiBoard;
    let playerShips, aiShips;
    let playerHits, aiHits;
    let aiMoves, aiTargetStack;
    let aiProbabilityMap;
    let currentPhase = "player_turn";
    let gameOver = false;
    let aiDifficulty = "normal";

    // DOM
    const playerBoardEl = document.getElementById('player-board');
    const aiBoardEl = document.getElementById('ai-board');
    const messageEl = document.getElementById('message');
    const restartBtn = document.getElementById('restart-btn');
    const difficultySelect = document.getElementById('difficulty');
    const aiGreetingEl = document.getElementById('ai-greeting');

    // AI respectful greetings
    const aiGreetings = {
      easy: "Hello, Captain! I'm your friendly AI opponent. I'll try my best to make this fun and fair for you.",
      normal: "Greetings, Admiral. I will play with focus and honor. Good luck!",
      hard: "Salutations, worthy adversary. I am ready to give you a formidable challenge. May the best tactician win!"
    };

    // Helpers
    function makeBoard() {
      return Array.from({length: SIZE}, () => Array(SIZE).fill(null));
    }
    function clone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }

    // Ship placement (random)
    function placeShipsRandom(board) {
      let ships = [];
      for (let ship of SHIPS) {
        let placed = false;
        let tries = 0;
        while (!placed && tries++ < 1000) {
          let dir = DIRS[Math.floor(Math.random() * 2)];
          let x = Math.floor(Math.random() * SIZE);
          let y = Math.floor(Math.random() * SIZE);
          let coords = [];
          for (let i = 0; i < ship.size; i++) {
            let nx = x + (dir === 'H' ? i : 0);
            let ny = y + (dir === 'V' ? i : 0);
            if (nx >= SIZE || ny >= SIZE) break;
            coords.push([nx, ny]);
          }
          if (coords.length !== ship.size) continue;
          // Check overlap
          if (coords.some(([cx, cy]) => board[cy][cx] !== null)) continue;
          // Place ship
          for (let [cx, cy] of coords) board[cy][cx] = ship.name;
          ships.push({
            name: ship.name,
            size: ship.size,
            coords: coords,
            hits: []
          });
          placed = true;
        }
        if (!placed) throw new Error("Couldn't place all ships!");
      }
      return ships;
    }

    // Rendering
    function renderBoards() {
      renderBoard(playerBoardEl, playerBoard, playerShips, true);
      renderBoard(aiBoardEl, aiBoard, aiShips, false);
    }
    function renderBoard(el, board, ships, isPlayer) {
      el.innerHTML = "";
      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.x = x;
          cell.dataset.y = y;
          if (isPlayer) cell.classList.add('own');
          // Show ships on player board
          if (isPlayer && board[y][x] && !playerHits[y][x]) {
            cell.classList.add('ship');
          }
          // Show hits/misses
          if (playerHits[y][x] && isPlayer) {
            cell.classList.add(board[y][x] ? 'hit' : 'miss');
            cell.textContent = board[y][x] ? '✕' : '•';
          } else if (aiHits[y][x] && !isPlayer) {
            cell.classList.add(board[y][x] ? 'hit' : 'miss');
            cell.textContent = board[y][x] ? '✕' : '•';
          }
          // Mark sunk ships' cells
          let sunkShips = ships.filter(s => s.hits.length === s.size);
          if (sunkShips.length) {
            for (let s of sunkShips) {
              for (let [sx, sy] of s.coords) {
                if (x === sx && y === sy) cell.classList.add('sunk');
              }
            }
          }
          if (!isPlayer && !gameOver && !aiHits[y][x]) {
            cell.addEventListener('click', () => handlePlayerShot(x, y));
          }
          el.appendChild(cell);
        }
      }
    }

    // Game init/reset
    function setupGame() {
      playerBoard = makeBoard();
      aiBoard = makeBoard();
      playerHits = makeBoard().map(row => row.map(_ => false));
      aiHits = makeBoard().map(row => row.map(_ => false));
      playerShips = placeShipsRandom(playerBoard);
      aiShips = placeShipsRandom(aiBoard);
      aiMoves = [];
      for (let y = 0; y < SIZE; y++) for (let x = 0; x < SIZE; x++) aiMoves.push([x, y]);
      shuffle(aiMoves);
      aiTargetStack = [];
      aiProbabilityMap = makeBoard().map(row => row.map(_ => 0));
      currentPhase = "player_turn";
      gameOver = false;
      aiDifficulty = difficultySelect.value;
      aiGreetingEl.textContent = aiGreetings[aiDifficulty];
      messageEl.textContent = "Your turn! Click the enemy board to fire.";
      renderBoards();
    }

    // AI logic - three difficulty levels
    function aiTurn() {
      if (gameOver) return;
      let shot;
      if (aiDifficulty === "easy") {
        // Random, never targets
        do {
          shot = aiMoves.pop();
        } while (shot && playerHits[shot[1]][shot[0]]);
      } else if (aiDifficulty === "normal") {
        // Same as original: random then target after hit
        if (aiTargetStack.length) {
          shot = aiTargetStack.pop();
          // Validate
          while (shot && playerHits[shot[1]][shot[0]]) {
            shot = aiTargetStack.pop();
          }
        }
        if (!shot) {
          do {
            shot = aiMoves.pop();
          } while (shot && playerHits[shot[1]][shot[0]]);
        }
      } else if (aiDifficulty === "hard") {
        // Probability-based hunting, targets intelligently
        shot = chooseHardAIMove();
      }
      if (!shot) return;
      let [x, y] = shot;
      playerHits[y][x] = true;
      let hitShip = playerShips.find(s => s.coords.some(([sx, sy]) => sx === x && sy === y));
      if (hitShip) {
        hitShip.hits.push([x, y]);
        // Easy: do nothing special
        if (aiDifficulty === "normal" || aiDifficulty === "hard") {
          // Add adjacent cells to target stack (but only if not already hit)
          let adj = [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]].filter(([nx, ny]) =>
            nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE && !playerHits[ny][nx]
          );
          shuffle(adj);
          aiTargetStack.push(...adj);
        }
        respectfulAIMessage("hit", hitShip);
        if (hitShip.hits.length === hitShip.size) {
          respectfulAIMessage("sunk", hitShip);
          // On hard, remove target stack cells not adjacent to this ship
          if (aiDifficulty === "hard") {
            aiTargetStack = aiTargetStack.filter(([tx, ty]) =>
              !hitShip.coords.some(([hx, hy]) =>
                Math.abs(tx - hx) + Math.abs(ty - hy) === 1
              )
            );
          }
        }
      } else {
        respectfulAIMessage("miss");
      }
      renderBoards();
      if (checkWin(playerShips, playerHits)) {
        respectfulAIMessage("win");
        gameOver = true;
        currentPhase = "game_over";
      } else {
        currentPhase = "player_turn";
      }
    }

    // Hard AI: Probability density algorithm
    function chooseHardAIMove() {
      // If in target mode, finish off found ship
      if (aiTargetStack.length) {
        let shot = aiTargetStack.pop();
        while (shot && playerHits[shot[1]][shot[0]]) {
          shot = aiTargetStack.pop();
        }
        if (shot) return shot;
      }
      // Hunt mode: calculate probability of each cell containing a ship
      let prob = makeBoard().map(row => row.map(_ => 0));
      let remaining = playerShips.filter(ship => ship.hits.length < ship.size).map(ship => ship.size);
      // For each ship size
      for (let s of remaining) {
        // Horizontal
        for (let y = 0; y < SIZE; y++) for (let x = 0; x <= SIZE - s; x++) {
          let fits = true;
          for (let i = 0; i < s; i++) {
            if (playerHits[y][x + i] && !isPlayerHitShip(x + i, y)) {fits = false; break;}
            if (playerHits[y][x + i] && isPlayerHitShip(x + i, y)) continue;
          }
          if (fits) for (let i = 0; i < s; i++) if (!playerHits[y][x + i]) prob[y][x + i]++;
        }
        // Vertical
        for (let x = 0; x < SIZE; x++) for (let y = 0; y <= SIZE - s; y++) {
          let fits = true;
          for (let i = 0; i < s; i++) {
            if (playerHits[y + i][x] && !isPlayerHitShip(x, y + i)) {fits = false; break;}
            if (playerHits[y + i][x] && isPlayerHitShip(x, y + i)) continue;
          }
          if (fits) for (let i = 0; i < s; i++) if (!playerHits[y + i][x]) prob[y + i][x]++;
        }
      }
      // Find max
      let max = 0, candidates = [];
      for (let y = 0; y < SIZE; y++) for (let x = 0; x < SIZE; x++) {
        if (!playerHits[y][x]) {
          if (prob[y][x] > max) {
            max = prob[y][x];
            candidates = [[x, y]];
          } else if (prob[y][x] === max) {
            candidates.push([x, y]);
          }
        }
      }
      // Break ties randomly; if all 0, pick random
      if (candidates.length) {
        shuffle(candidates);
        return candidates[0];
      } else {
        // fallback to random
        let moves = [];
        for (let y = 0; y < SIZE; y++) for (let x = 0; x < SIZE; x++) if (!playerHits[y][x]) moves.push([x, y]);
        shuffle(moves);
        return moves[0];
      }
    }
    function isPlayerHitShip(x, y) {
      return playerShips.some(s => s.coords.some(([sx, sy]) => sx === x && sy === y) && s.hits.some(([hx, hy]) => hx === x && hy === y));
    }

    // Player shot handler
    function handlePlayerShot(x, y) {
      if (currentPhase !== "player_turn" || gameOver) return;
      if (aiHits[y][x]) return; // Already fired
      aiHits[y][x] = true;
      let hitShip = aiShips.find(s => s.coords.some(([sx, sy]) => sx === x && sy === y));
      if (hitShip) {
        hitShip.hits.push([x, y]);
        respectfulPlayerMessage("hit", hitShip);
        renderBoards();
        if (hitShip.hits.length === hitShip.size) {
          respectfulPlayerMessage("sunk", hitShip);
        }
        if (checkWin(aiShips, aiHits)) {
          respectfulPlayerMessage("win");
          gameOver = true;
          currentPhase = "game_over";
          renderBoards();
          return;
        }
      } else {
        respectfulPlayerMessage("miss");
      }
      renderBoards();
      currentPhase = "ai_turn";
      setTimeout(aiTurn, 900);
    }

    // Win check
    function checkWin(ships, hitsBoard) {
      return ships.every(ship =>
        ship.coords.every(([x, y]) => hitsBoard[y][x])
      );
    }

    // UI
    function showMessage(msg) {
      messageEl.textContent = msg;
    }
    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    // Respectful AI messages
    function respectfulAIMessage(type, ship) {
      if (type === "hit") {
        showMessage("The AI respectfully reports: 'I have hit your ship.'");
      } else if (type === "sunk") {
        showMessage(`The AI says: 'I have sunk your ${ship.name}. Well played, Captain.'`);
      } else if (type === "miss") {
        showMessage("The AI reports: 'My shot missed. Your turn!'");
      } else if (type === "win") {
        showMessage("The AI congratulates you: 'Victory is mine this time. Thank you for an excellent game!'");
      }
    }
    function respectfulPlayerMessage(type, ship) {
      if (type === "hit") {
        showMessage("You hit an enemy ship! The AI says: 'A solid shot!'");
      } else if (type === "sunk") {
        showMessage(`You sunk the enemy's ${ship.name}! The AI remarks: 'A fine display of tactics.'`);
      } else if (type === "miss") {
        showMessage("You missed. The AI: 'No worries, that was a close one!'");
      } else if (type === "win") {
        showMessage("You win! The AI bows: 'Congratulations, you are the superior tactician!'");
      }
    }

    // Difficulty change
    difficultySelect.onchange = () => {
      aiDifficulty = difficultySelect.value;
      aiGreetingEl.textContent = aiGreetings[aiDifficulty];
      setupGame();
    };

    // Restart
    restartBtn.onclick = setupGame;

    // Start
    setupGame();
  </script>
</body>

</html>
