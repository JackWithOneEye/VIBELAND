<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Simulator - VIBELAND</title>
  <link rel="stylesheet" type="text/css" href="../assets/styles.css">
  <style>
    button {
      padding: 8px 12px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="container wide">
    <div class="outer-border">
      <div class="header">
        <h1>⚛️ PARTICLE SIMULATOR ⚛️</h1>
        <p>~*~ Watch Physics Come Alive ~*~</p>
      </div>

      <div class="ticker" aria-label="site news">
        <div class="marquee">★ WELCOME TO VIBELAND ★ CREATE SAND, WATER & MORE ★ WATCH GRAVITY IN ACTION ★</div>
      </div>

      <div class="content">
        <div class="simulator">
          <canvas id="canvas" width="800" height="600"></canvas>

          <div class="controls">
            <button data-type="eraser">Eraser</button>
            <button data-type="wall">Wall</button>
            <button data-type="stone">Stone</button>
            <button data-type="sand">Sand</button>
            <button data-type="water">Water</button>
          </div>
        </div>
        
        <hr class="thick">
        
        <div class="footer">
          <div><a href="../home">← Back to VIBELAND</a></div>
          <div>© 1999 VIBELAND - All Rights Reserved</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const cellSize = 4;
    const gridWidth = canvas.width / cellSize;
    const gridHeight = canvas.height / cellSize;

    let grid = Array.from({length: gridHeight}, () => Array(gridWidth).fill('empty'));

    const particles = {
      empty: {color: '#fff'},
      wall: {color: '#333'},
      stone: {color: '#888'},
      sand: {color: '#ffd700'},
      water: {color: '#00bfff'}
    };

    const density = {
      empty: 0,
      water: 1,
      sand: 2,
      stone: 3,
      wall: 1000
    };

    const MAX_WATER_SPREAD = 6;
    const WATER_MOMENTUM_STEPS = 3;

    let tick = 0;
    let waterMomentum = Array.from({ length: gridHeight }, () => Array(gridWidth).fill(0));

    let selectedType = 'sand';

    let isMouseDown = false;

    function getGridPos(x, y) {
      return {
        gx: Math.floor(x / cellSize),
        gy: Math.floor(y / cellSize)
      };
    }

    function placeParticle(gx, gy, type) {
      if (gx >= 0 && gx < gridWidth && gy >= 0 && gy < gridHeight) {
        grid[gy][gx] = type === 'eraser' ? 'empty' : type;
        waterMomentum[gy][gx] = 0;
      }
    }

    canvas.addEventListener('mousedown', (e) => {
      isMouseDown = true;
      const rect = canvas.getBoundingClientRect();
      const {gx, gy} = getGridPos(e.clientX - rect.left, e.clientY - rect.top);
      placeParticle(gx, gy, selectedType);
    });

    canvas.addEventListener('mouseup', () => {
      isMouseDown = false;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (isMouseDown) {
        const rect = canvas.getBoundingClientRect();
        const {gx, gy} = getGridPos(e.clientX - rect.left, e.clientY - rect.top);
        placeParticle(gx, gy, selectedType);
      }
    });

    document.querySelectorAll('button').forEach(button => {
      button.addEventListener('click', () => {
        document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        button.classList.add('active');
        selectedType = button.dataset.type;
      });
    });

    document.querySelector('button[data-type="sand"]').classList.add('active');

    function simulate() {
      let newGrid = grid.map(row => row.slice());
      let newMomentum = waterMomentum.map(row => row.slice());

      const xStart = (tick % 2 === 0) ? 0 : gridWidth - 1;
      const xStep  = (tick % 2 === 0) ? 1 : -1;

      const swap = (x1, y1, x2, y2) => {
        const t1 = newGrid[y1][x1];
        const t2 = newGrid[y2][x2];
        newGrid[y1][x1] = t2;
        newGrid[y2][x2] = t1;

        const m1 = newMomentum[y1][x1];
        const m2 = newMomentum[y2][x2];

        newMomentum[y1][x1] = (t2 === 'water') ? m2 : 0;
        newMomentum[y2][x2] = (t1 === 'water') ? m1 : 0;
      };

      const findDrop = (gx, gy, dir) => {
        for (let d = 1; d <= MAX_WATER_SPREAD; d++) {
          const cx = gx + dir * d;
          if (cx < 0 || cx >= gridWidth) break;
          if (grid[gy][cx] !== 'empty') break;
          if (gy + 1 < gridHeight && grid[gy + 1][cx] === 'empty') return d;
        }
        return null;
      };

      for (let y = gridHeight - 1; y >= 0; y--) {
        for (let i = 0; i < gridWidth; i++) {
          const x = xStart + i * xStep;
          if (x < 0 || x >= gridWidth) continue;

          const type = grid[y][x];
          if (type === 'empty' || type === 'wall') continue;

          const belowY = y + 1;
          const leftX = x - 1;
          const rightX = x + 1;

          const below = (belowY < gridHeight) ? grid[belowY][x] : null;

          if (type === 'stone') {
            if (below && density[below] < density.stone) {
              swap(x, y, x, y + 1);
            }
            continue;
          }

          if (type === 'sand') {
            if (below && density[below] < density.sand) {
              swap(x, y, x, y + 1);
            } else {
              const canDL =
                y + 1 < gridHeight && x - 1 >= 0 &&
                density[grid[y + 1][x - 1]] < density.sand;
              const canDR =
                y + 1 < gridHeight && x + 1 < gridWidth &&
                density[grid[y + 1][x + 1]] < density.sand;

              if (canDL && canDR) {
                if ((tick + x) % 2 === 0) {
                  swap(x, y, x - 1, y + 1);
                } else {
                  swap(x, y, x + 1, y + 1);
                }
              } else if (canDL) {
                swap(x, y, x - 1, y + 1);
              } else if (canDR) {
                swap(x, y, x + 1, y + 1);
              }
            }
            continue;
          }

          if (type === 'water') {
            if (below && density[below] < density.water) {
              swap(x, y, x, y + 1);
              newMomentum[y + 1][x] = 0;
              newMomentum[y][x] = 0;
              continue;
            }

            const canDL =
              y + 1 < gridHeight && x - 1 >= 0 &&
              density[grid[y + 1][x - 1]] < density.water;
            const canDR =
              y + 1 < gridHeight && x + 1 < gridWidth &&
              density[grid[y + 1][x + 1]] < density.water;

            if (canDL && canDR) {
              if ((tick + x) % 2 === 0) {
                swap(x, y, x - 1, y + 1);
                newMomentum[y + 1][x - 1] = -1;
              } else {
                swap(x, y, x + 1, y + 1);
                newMomentum[y + 1][x + 1] = 1;
              }
              continue;
            } else if (canDL) {
              swap(x, y, x - 1, y + 1);
              newMomentum[y + 1][x - 1] = -1;
              continue;
            } else if (canDR) {
              swap(x, y, x + 1, y + 1);
              newMomentum[y + 1][x + 1] = 1;
              continue;
            }

            const leftDrop = findDrop(x, y, -1);
            const rightDrop = findDrop(x, y, 1);

            let dir = 0;
            if (leftDrop != null && rightDrop != null) {
              dir = (leftDrop === rightDrop)
                ? (((tick + y) % 2 === 0) ? -1 : 1)
                : (leftDrop < rightDrop ? -1 : 1);
            } else if (leftDrop != null) {
              dir = -1;
            } else if (rightDrop != null) {
              dir = 1;
            } else {
              const m = Math.sign(waterMomentum[y][x]);
              if (m !== 0) {
                const nx = x + m;
                if (nx >= 0 && nx < gridWidth && grid[y][nx] === 'empty') {
                  dir = m;
                }
              }
            }

            if (dir !== 0) {
              const nx = x + dir;
              if (nx >= 0 && nx < gridWidth && grid[y][nx] === 'empty') {
                swap(x, y, nx, y);
                newMomentum[y][nx] = dir * WATER_MOMENTUM_STEPS;
                newMomentum[y][x] = 0;
                continue;
              }
            }

            const currentM = waterMomentum[y][x];
            if (currentM !== 0) {
              const s = Math.sign(currentM);
              const mag = Math.abs(currentM) - 1;
              newMomentum[y][x] = mag > 0 ? s * mag : 0;
            }
          }
        }
      }

      grid = newGrid;
      waterMomentum = newMomentum;
    }

    function render() {
      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          const type = grid[y][x];
          ctx.fillStyle = particles[type].color;
          ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
      }
    }

    function loop() {
      tick++;
      simulate();
      render();
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>
