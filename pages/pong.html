<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pong - VIBELAND</title>
    <link rel="stylesheet" type="text/css" href="../assets/styles.css">
    <style type="text/css">
        #pong {
            background: #000080;
            border: 2px inset #c0c0c0;
            cursor: crosshair;
        }
        
        .game-container {
            background-color: #ffffff;
            border: 2px inset #c0c0c0;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }
        
        .score-display {
            background-color: #ffffff;
            border: 2px inset #c0c0c0;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .player-score {
            font-size: 24px;
            font-weight: bold;
            color: #000080;
            font-family: "Courier New", monospace;
        }
        
        .score-label {
            font-size: 14px;
            color: #000000;
            margin-bottom: 5px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .controls label {
            margin-bottom: 4px;
            color: #000000;
            font-weight: bold;
            font-size: 12px;
        }

        .controls select {
            font-size: 14px;
            padding: 2px 6px;
            background-color: #ffffff;
            border: 2px inset #c0c0c0;
            color: #000000;
            font-family: "Times New Roman", serif;
            cursor: pointer;
        }

        .controls select:focus {
            outline: none;
            border: 2px outset #c0c0c0;
        }
    </style>
</head>

<body>
    <div class="container wide">
        <div class="outer-border">
            <div class="header">
                <h1>üèì PONG üèì</h1>
                <p>~*~ Classic Arcade Action ~*~</p>
            </div>

            <div class="ticker" aria-label="site news">
                <div class="marquee">‚òÖ WELCOME TO VIBELAND ‚òÖ CLASSIC PONG GAME ‚òÖ BEAT THE AI ‚òÖ</div>
            </div>

            <div class="content">
                <div class="score-display">
            <div>
                <div class="score-label">PLAYER</div>
                <div class="player-score" id="playerScore">0</div>
            </div>
            <div class="controls">
                <label for="difficulty">AI Difficulty:</label>
                <select id="difficulty">
                    <option value="easy" selected>Easy</option>
                    <option value="normal">Normal</option>
                    <option value="hard">Hard</option>
                </select>
            </div>
            <div>
                <div class="score-label">COMPUTER</div>
                <div class="player-score" id="computerScore">0</div>
            </div>
                </div> 
                <div class="game-container">
                    <canvas id="pong" width="800" height="500"></canvas>
                </div>

                <hr class="thick">

                <div class="footer">
                    <div><a href="../home">‚Üê Back to VIBELAND</a></div>
                    <div>¬© 1999 VIBELAND - All Rights Reserved</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('pong');
        const ctx = canvas.getContext('2d');
        const difficultySelect = document.getElementById('difficulty');

        // Game Settings
        const PADDLE_WIDTH = 12;
        const PADDLE_HEIGHT = 90;
        const BALL_SIZE = 14;
        const PADDLE_SPEED = 5;
        const AI_SPEED = 4;
        const BALL_SPEED = 6;

        // AI Difficulty Settings
        const AI_DIFFICULTY = {
            easy:   { speed: 2, reaction: 0.15, error: 80, delay: 0.3 },
            normal: { speed: 4, reaction: 0.4, error: 40, delay: 0.1 },
            hard:   { speed: 6, reaction: 0.8, error: 15, delay: 0.05 }
        };
        let aiLevel = 'easy';

        // Score variables
        let playerScore = 0;
        let computerScore = 0;

        // Paddle and Ball State
        let leftPaddle = {
            x: 0 + 10,
            y: canvas.height / 2 - PADDLE_HEIGHT / 2,
            width: PADDLE_WIDTH,
            height: PADDLE_HEIGHT
        };

        let rightPaddle = {
            x: canvas.width - PADDLE_WIDTH - 10,
            y: canvas.height / 2 - PADDLE_HEIGHT / 2,
            width: PADDLE_WIDTH,
            height: PADDLE_HEIGHT
        };

        let ball = {
            x: canvas.width / 2 - BALL_SIZE / 2,
            y: canvas.height / 2 - BALL_SIZE / 2,
            width: BALL_SIZE,
            height: BALL_SIZE,
            dx: BALL_SPEED * (Math.random() > 0.5 ? 1 : -1),
            dy: BALL_SPEED * ((Math.random() * 2 - 1) * 0.7)
        };

        // Update score display
        function updateScore() {
            document.getElementById('playerScore').textContent = playerScore;
            document.getElementById('computerScore').textContent = computerScore;
        }

        // Mouse Control for Left Paddle
        canvas.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            let mouseY = e.clientY - rect.top;
            leftPaddle.y = mouseY - PADDLE_HEIGHT / 2;
            // Clamp within bounds
            if (leftPaddle.y < 0) leftPaddle.y = 0;
            if (leftPaddle.y + PADDLE_HEIGHT > canvas.height)
                leftPaddle.y = canvas.height - PADDLE_HEIGHT;
        });

        // Change difficulty
        difficultySelect.addEventListener('change', function() {
            aiLevel = this.value;
        });

        // Draw Everything
        function drawRect(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, w, h);
        }

        function drawBall(x, y, size, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x + size/2, y + size/2, size/2, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawNet() {
            ctx.strokeStyle = "#c0c0c0";
            ctx.lineWidth = 4;
            for (let i = 0; i < canvas.height; i += 36) {
                ctx.beginPath();
                ctx.moveTo(canvas.width/2, i);
                ctx.lineTo(canvas.width/2, i+18);
                ctx.stroke();
            }
        }

        // Collision
        function collide(p, b) {
            return (
                b.x < p.x + p.width &&
                b.x + b.width > p.x &&
                b.y < p.y + p.height &&
                b.y + b.height > p.y
            );
        }

        // Reset Ball
        function resetBall() {
            ball.x = canvas.width / 2 - BALL_SIZE / 2;
            ball.y = canvas.height / 2 - BALL_SIZE / 2;
            ball.dx = BALL_SPEED * (Math.random() > 0.5 ? 1 : -1);
            ball.dy = BALL_SPEED * ((Math.random() * 2 - 1) * 0.7);
        }

        // AI Movement
        let aiErrorOffset = 0; // Used for simulating error/bias
        let aiReactionTimer = 0; // Timer for reaction delay
        
        function moveAIPaddle() {
            const ai = AI_DIFFICULTY[aiLevel];
            let paddleCenter = rightPaddle.y + PADDLE_HEIGHT/2;
            
            // Only react if ball is moving towards AI paddle
            let ballApproaching = ball.dx > 0;
            
            if (ballApproaching) {
                // Increment reaction timer when ball is approaching
                aiReactionTimer += 1/60; // Assuming 60fps
            } else {
                // Reset reaction timer when ball moves away
                aiReactionTimer = 0;
            }
            
            // Only move after reaction delay has passed
            if (ballApproaching && aiReactionTimer >= ai.delay) {
                // Calculate target position with error
                let targetY = ball.y + BALL_SIZE/2 + aiErrorOffset;
                
                // Add some prediction for higher difficulties
                if (aiLevel === 'hard') {
                    // Predict where ball will be when it reaches the paddle
                    let timeToReach = (canvas.width - ball.x - BALL_SIZE) / Math.abs(ball.dx);
                    targetY += ball.dy * timeToReach;
                } else if (aiLevel === 'normal') {
                    // Slight prediction
                    let timeToReach = (canvas.width - ball.x - BALL_SIZE) / Math.abs(ball.dx);
                    targetY += ball.dy * timeToReach * 0.5;
                }
                
                // Calculate movement needed
                let diff = targetY - paddleCenter;
                
                // Move towards target with reaction speed
                let moveAmount = diff * ai.reaction;
                
                // Limit movement speed
                let maxMove = ai.speed;
                if (Math.abs(moveAmount) > maxMove) {
                    moveAmount = Math.sign(moveAmount) * maxMove;
                }
                
                rightPaddle.y += moveAmount;
            }
            
            // Clamp within bounds
            if (rightPaddle.y < 0) rightPaddle.y = 0;
            if (rightPaddle.y + PADDLE_HEIGHT > canvas.height)
                rightPaddle.y = canvas.height - PADDLE_HEIGHT;
            
            // Update error offset occasionally for "inaccuracy"
            if (Math.random() < 0.02) { // Reduced frequency
                aiErrorOffset = (Math.random() - 0.5) * ai.error;
            }
        }

        // Main Game Loop
        function update() {
            // Move Ball
            ball.x += ball.dx;
            ball.y += ball.dy;

            // Wall collision
            if (ball.y < 0) {
                ball.y = 0;
                ball.dy *= -1;
            }
            if (ball.y + BALL_SIZE > canvas.height) {
                ball.y = canvas.height - BALL_SIZE;
                ball.dy *= -1;
            }

            // Left paddle collision
            if (collide(leftPaddle, ball)) {
                ball.x = leftPaddle.x + leftPaddle.width + 1;
                ball.dx *= -1;
                // Add some "spin" based on where it hit
                let collidePoint = (ball.y + BALL_SIZE/2) - (leftPaddle.y + PADDLE_HEIGHT/2);
                ball.dy = collidePoint * 0.25;
            }

            // Right paddle collision
            if (collide(rightPaddle, ball)) {
                ball.x = rightPaddle.x - BALL_SIZE - 1;
                ball.dx *= -1;
                let collidePoint = (ball.y + BALL_SIZE/2) - (rightPaddle.y + PADDLE_HEIGHT/2);
                ball.dy = collidePoint * 0.25;
            }

            // Score (Ball out of bounds)
            if (ball.x < 0) {
                computerScore++;
                updateScore();
                resetBall();
            } else if (ball.x > canvas.width) {
                playerScore++;
                updateScore();
                resetBall();
            }

            // AI movement
            moveAIPaddle();
        }

        function render() {
            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw net
            drawNet();

            // Draw paddles and ball
            drawRect(leftPaddle.x, leftPaddle.y, leftPaddle.width, leftPaddle.height, '#c0c0c0');
            drawRect(rightPaddle.x, rightPaddle.y, rightPaddle.width, rightPaddle.height, '#c0c0c0');
            drawBall(ball.x, ball.y, BALL_SIZE, '#ffffff');
        }

        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Initialize score display
        updateScore();
        gameLoop();
    </script>
</body>
</html>
