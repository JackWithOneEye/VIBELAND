<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>String Vibration - VIBELAND</title>
  <link rel="stylesheet" type="text/css" href="../assets/styles.css">
  <style>
    .controls {
      gap: 20px;
      background-color: #c0c0c0;
      padding: 15px;
      border: 2px inset #c0c0c0;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <div class="container wide">
    <div class="outer-border">
      <div class="header">
        <h1>üé∏ STRING VIBRATION üé∏</h1>
        <p>~*~ Feel the Waves ~*~</p>
      </div>

      <div class="ticker" aria-label="site news">
        <div class="marquee">‚òÖ WELCOME TO VIBELAND ‚òÖ PLUCK THE STRING ‚òÖ ADJUST TENSION & DAMPING ‚òÖ</div>
      </div>

      <div class="content">
        <div class="simulator">
          <canvas id="stringCanvas" width="800" height="400"></canvas>
        </div>

        <div class="controls">
          <div class="control-group">
            <label for="tension">TENSION <span id="tensionVal">900</span></label>
            <input type="range" id="tension" min="300" max="1200" value="900" step="50">
          </div>
          <div class="control-group">
            <label for="damping">DAMPING <span id="dampingVal">1.5</span></label>
            <input type="range" id="damping" min="0.5" max="4" value="1.5" step="0.1">
          </div>
          <div class="control-group">
            <label for="pluckRadius">PLUCK SIZE <span id="pluckRadiusVal">12</span></label>
            <input type="range" id="pluckRadius" min="6" max="20" value="12" step="1">
          </div>
          <div class="control-group">
            <button id="resetBtn" class="neon-btn">RESET</button>
            <button id="pauseBtn" class="neon-btn">PAUSE</button>
          </div>
        </div>

        <div class="instructions">
          <h3>HOW TO USE</h3>
          <p>Click and drag anywhere on the string to pull it up or down, and move sideways to slide the pluck point.
            Release to watch the vibrations propagate along the string. Adjust the controls to change the string's physical
            properties:</p>
          <p><strong>TENSION:</strong> Higher values create faster wave propagation<br>
            <strong>DAMPING:</strong> Controls how quickly vibrations fade out<br>
            <strong>PLUCK SIZE:</strong> Controls the width of your finger contact area
          </p>
        </div>
        
        <hr class="thick">
        
        <div class="footer">
          <div><a href="../home">‚Üê Back to VIBELAND</a></div>
          <div>¬© 1999 VIBELAND - All Rights Reserved</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    class StringSimulation {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');

        this.N = 256;
        this.margin = 40;
        this.midlineY = this.canvas.height / 2;
        this.L = this.canvas.width - 2 * this.margin;
        this.dx = this.L / (this.N - 1);

        this.dt = 1 / 360;
        this.c = 900;
        this.zeta = 1.5;
        this.R = 12;

        this.updatePhysicsParameters();

        this.y = new Float32Array(this.N);
        this.yPrev = new Float32Array(this.N);
        this.yNext = new Float32Array(this.N);

        this.xPos = new Float32Array(this.N);
        for (let i = 0; i < this.N; i++) {
          this.xPos[i] = this.margin + i * this.dx;
        }

        this.isDragging = false;
        this.sGrab = -1;
        this.dragTarget = 0;

        this.accumulator = 0;
        this.lastTime = performance.now();
        this.isPaused = false;

        this.setupEventListeners();
        this.setupControls();
        this.start();
      }

      updatePhysicsParameters() {
        const safety = 0.98;
        const newDt = safety * (this.dx / this.c);

        if (this.dt && this.y && this.yPrev) {
          const scale = newDt / this.dt;
          for (let i = 0; i < this.N; i++) {
            this.yPrev[i] = this.y[i] - scale * (this.y[i] - this.yPrev[i]);
          }
        }
        this.dt = newDt;

        this.r2 = (this.c * this.dt / this.dx) ** 2;

        this.g0 = 2 * this.zeta * this.dt;

        const alpha = 0.03;
        this.g1 = 2 * alpha * this.zeta * this.dt / (this.dx * this.dx);
      }

      toLocal(event) {
        const rect = this.canvas.getBoundingClientRect();
        return {
          x: (event.clientX - rect.left) * (this.canvas.width / rect.width),
          y: (event.clientY - rect.top) * (this.canvas.height / rect.height)
        };
      }

      setupEventListeners() {
        this.canvas.style.touchAction = 'none';

        this.canvas.addEventListener('pointerdown', (ev) => {
          this.canvas.setPointerCapture(ev.pointerId);
          const p = this.toLocal(ev);
          const s = (p.x - this.margin) / this.dx;
          if (s > 0 && s < this.N - 1) {
            this.isDragging = true;
            this.sGrab = Math.max(1.000001, Math.min(this.N - 2.000001, s));

            const maxDisp = 0.45 * this.canvas.height;
            this.dragTarget = Math.max(-maxDisp, Math.min(maxDisp, this.midlineY - p.y));

            this.fillTrapezoidProfile(this.sGrab, this.dragTarget, this.R, this.y);
            this.yPrev.set(this.y);
          }
        });

        this.canvas.addEventListener('pointermove', (ev) => {
          if (!this.isDragging) return;
          const p = this.toLocal(ev);
          const s = (p.x - this.margin) / this.dx;
          this.sGrab = Math.max(1.000001, Math.min(this.N - 2.000001, s));

          const maxDisp = 0.45 * this.canvas.height;
          this.dragTarget = Math.max(-maxDisp, Math.min(maxDisp, this.midlineY - p.y));

          this.fillTrapezoidProfile(this.sGrab, this.dragTarget, this.R, this.y);
          this.yPrev.set(this.y);
        });

        const endDrag = () => {
          if (this.isDragging && this.sGrab >= 0) {
            this.fillTrapezoidProfile(this.sGrab, this.dragTarget, this.R, this.y);
            this.yPrev.set(this.y);
          }
          this.isDragging = false;
          this.sGrab = -1;
        };

        this.canvas.addEventListener('pointerup', endDrag);
        this.canvas.addEventListener('pointercancel', endDrag);
      }

      setupControls() {
        const tensionSlider = document.getElementById('tension');
        const dampingSlider = document.getElementById('damping');
        const radiusSlider = document.getElementById('pluckRadius');
        const resetBtn = document.getElementById('resetBtn');
        const pauseBtn = document.getElementById('pauseBtn');

        tensionSlider.addEventListener('input', (e) => {
          if (!this.isDragging) {
            this.c = parseFloat(e.target.value);
            this.updatePhysicsParameters();
          }
          document.getElementById('tensionVal').textContent = e.target.value;
        });

        dampingSlider.addEventListener('input', (e) => {
          if (!this.isDragging) {
            this.zeta = parseFloat(e.target.value);
            this.updatePhysicsParameters();
          }
          document.getElementById('dampingVal').textContent = e.target.value;
        });

        radiusSlider.addEventListener('input', (e) => {
          this.R = parseInt(e.target.value);
          document.getElementById('pluckRadiusVal').textContent = e.target.value;
        });

        resetBtn.addEventListener('click', () => {
          this.reset();
        });

        pauseBtn.addEventListener('click', () => {
          this.togglePause();
        });
      }

      reset() {
        this.y.fill(0);
        this.yPrev.fill(0);
        this.accumulator = 0;
      }

      togglePause() {
        this.isPaused = !this.isPaused;
        const pauseBtn = document.getElementById('pauseBtn');

        if (this.isPaused) {
          pauseBtn.textContent = 'RESUME';
          pauseBtn.classList.add('paused');
        } else {
          pauseBtn.textContent = 'PAUSE';
          pauseBtn.classList.remove('paused');
          this.lastTime = performance.now();
        }
      }

      fillTrapezoidProfile(sApex, yApex, R, dest) {
        const L = this.N - 1;
        const eps = 1e-6;
        const s = Math.max(1 + eps, Math.min(L - 1 - eps, sApex));
        const w = Math.max(0, Math.min(R, Math.min(s - (1 + eps), (L - 1 - eps) - s)));
        const left = s - w;
        const right = s + w;

        for (let i = 0; i <= L; i++) {
          let y;
          if (i <= left) {
            y = yApex * (i / left);
          } else if (i >= right) {
            y = yApex * ((L - i) / (L - right));
          } else {
            y = yApex;
          }
          dest[i] = y;
        }
        dest[0] = 0;
        dest[L] = 0;
      }

      applyDragConstraint() {
        if (!this.isDragging || this.sGrab < 0) return;
        this.fillTrapezoidProfile(this.sGrab, this.dragTarget, this.R, this.y);
        this.yPrev.set(this.y);
      }

      stepOnce() {
        this.applyDragConstraint();

        for (let i = 1; i < this.N - 1; i++) {
          const lap = this.y[i - 1] - 2 * this.y[i] + this.y[i + 1];
          const vel = this.y[i] - this.yPrev[i];
          const lapVel = (this.y[i - 1] - this.yPrev[i - 1])
            - 2 * vel
            + (this.y[i + 1] - this.yPrev[i + 1]);

          this.yNext[i] = 2 * this.y[i] - this.yPrev[i]
            + this.r2 * lap
            - this.g0 * vel
            - this.g1 * lapVel;
        }

        this.yNext[0] = 0;
        this.yNext[this.N - 1] = 0;

        if (this.isDragging && this.sGrab >= 0) {
          this.fillTrapezoidProfile(this.sGrab, this.dragTarget, this.R, this.yNext);
        }

        const temp = this.yPrev;
        this.yPrev = this.y;
        this.y = this.yNext;
        this.yNext = temp;
      }

      draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.imageSmoothingEnabled = true;

        this.ctx.shadowColor = '#000000';
        this.ctx.shadowBlur = 2;
        this.ctx.strokeStyle = '#000000';
        this.ctx.lineWidth = 2;

        this.ctx.beginPath();
        this.ctx.moveTo(this.xPos[0], this.midlineY - this.y[0]);

        for (let i = 1; i < this.N; i++) {
          this.ctx.lineTo(this.xPos[i], this.midlineY - this.y[i]);
        }

        this.ctx.stroke();

        this.ctx.shadowColor = 'transparent';
        this.ctx.shadowBlur = 0;

        this.ctx.fillStyle = '#666';
        this.ctx.fillRect(this.xPos[0] - 3, this.midlineY - 3, 6, 6);
        this.ctx.fillRect(this.xPos[this.N - 1] - 3, this.midlineY - 3, 6, 6);
      }

      frame(currentTime) {
        if (!this.isPaused) {
          const deltaTime = (currentTime - this.lastTime) / 1000;
          this.lastTime = currentTime;
          this.accumulator += deltaTime;

          const MAX_SUBSTEPS = 240;
          this.accumulator = Math.min(this.accumulator, MAX_SUBSTEPS * this.dt);

          let steps = 0;
          const maxSteps = 32;
          while (this.accumulator >= this.dt && steps < maxSteps) {
            this.stepOnce();
            this.accumulator -= this.dt;
            steps++;
          }
        } else {
          this.lastTime = currentTime;
        }

        this.draw();
        requestAnimationFrame((time) => this.frame(time));
      }

      start() {
        requestAnimationFrame((time) => this.frame(time));
      }
    }

    window.addEventListener('load', () => {
      new StringSimulation('stringCanvas');
    });
  </script>
</body>
</html>
